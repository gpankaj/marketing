{
  "_args": [
    [
      {
        "raw": "ts-promise",
        "scope": null,
        "escapedName": "ts-promise",
        "name": "ts-promise",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "C:\\Users\\pankajg\\Desktop\\nodejs\\april"
    ]
  ],
  "_from": "ts-promise@latest",
  "_id": "ts-promise@0.3.4",
  "_inCache": true,
  "_location": "/ts-promise",
  "_nodeVersion": "4.4.7",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/ts-promise-0.3.4.tgz_1477602785712_0.6826638192869723"
  },
  "_npmUser": {
    "name": "poelstra",
    "email": "martin@beryllium.net"
  },
  "_npmVersion": "4.0.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "ts-promise",
    "scope": null,
    "escapedName": "ts-promise",
    "name": "ts-promise",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/ts-promise/-/ts-promise-0.3.4.tgz",
  "_shasum": "165ff9ad521476d93c005601eefe5bb92d579cbe",
  "_shrinkwrap": null,
  "_spec": "ts-promise",
  "_where": "C:\\Users\\pankajg\\Desktop\\nodejs\\april",
  "author": {
    "name": "Martin Poelstra",
    "email": "martin@beryllium.net"
  },
  "bugs": {
    "url": "https://github.com/poelstra/ts-promise/issues"
  },
  "dependencies": {},
  "description": "Fast, robust, type-safe promises",
  "devDependencies": {
    "@types/chai": "^3.4.34",
    "@types/mocha": "^2.2.32",
    "@types/node": "^6.0.45",
    "@types/source-map-support": "^0.2.28",
    "browserify": "^13.0.1",
    "chai": "^2.2.0",
    "coveralls": "^2.11.11",
    "istanbul": "^0.3.22",
    "mocha": "^2.5.3",
    "promises-aplus-tests": "^2.1.2",
    "remap-istanbul": "^0.6.4",
    "rimraf": "^2.5.4",
    "source-map-support": "^0.4.2",
    "tslint": "^3.13.0",
    "typescript": "^2.0.3",
    "uglify-js": "^2.7.3"
  },
  "directories": {},
  "dist": {
    "shasum": "165ff9ad521476d93c005601eefe5bb92d579cbe",
    "tarball": "https://registry.npmjs.org/ts-promise/-/ts-promise-0.3.4.tgz"
  },
  "gitHead": "de46fc403e1ef77b481b55c92794015b73225ca8",
  "homepage": "https://github.com/poelstra/ts-promise",
  "keywords": [
    "promise",
    "typescript",
    "promises-aplus"
  ],
  "license": "MIT",
  "main": "./dist/lib/index.js",
  "maintainers": [
    {
      "name": "poelstra",
      "email": "martin@beryllium.net"
    }
  ],
  "name": "ts-promise",
  "optionalDependencies": {},
  "readme": "<a href=\"https://promisesaplus.com/\">\n\t<img src=\"https://promisesaplus.com/assets/logo-small.png\"\n\t\talt=\"Promises/A+ logo\"\n\t\ttitle=\"Promises/A+ 1.1 compliant\" align=\"right\" />\n</a>\n\n[![Build Status](https://travis-ci.org/poelstra/ts-promise.svg)](https://travis-ci.org/poelstra/ts-promise)\n[![Coverage Status](https://coveralls.io/repos/poelstra/ts-promise/badge.svg)](https://coveralls.io/r/poelstra/ts-promise)\n\n# Introduction\n\nTS-Promise is a fast, robust, type-safe promise library.\n\nFeatures:\n- Promises/A+ 1.1 compliant\n- ES6 Promise interface compatible\n- Long stack traces support (switchable at runtime!)\n- [Fast](https://github.com/poelstra/ts-promise-benchmark)\n- Small (gzipped minified version 0.3.1 weighs only 3.5kB, everything included)\n- Efficiently supports infinite recursion (with and without long stack traces)\n- Early throwing of unhandled rejections with `.done()`\n- No progression handlers\n- Optional explicit promise chain flushing, useful for test frameworks\n- Readable code (not too many tricks)\n\nFor other planned features, see the TODO below.\n\n# Usage example\n\nInstall using `npm`:\n```\ncd your-project\nnpm install --save ts-promise\n```\n\nIf you use TypeScript, use `\"moduleResolution\": \"node\"` in your `tsconfig.json`\nto let it automatically pick up the typings of this package.\n\n\n```ts\n// Example using ES6 syntax (e.g. using Typescript or Babel)\n\nimport Promise from \"ts-promise\";\n// or e.g. var Promise = require(\"ts-promise\").Promise;\n\n// Hello world\nPromise.resolve(\"hello world\").then((v) => {\n\tconsole.log(v);\n});\n\n// Long stack traces demo\nPromise.setLongTraces(true);\nvar p = Promise.resolve();\np.then(() => {\n\treturn Promise.reject(new Error(\"my error\"));\n}).catch((e) => {\n\tconsole.error(e.stack);\n});\n```\n\nExample output of the above:\n```\n\"hello world\"\nError: my error\n    at /home/martin/src/promise-example/example.js:9:35\n    at Promise._unwrap (/home/martin/src/ts-promise/src/lib/Promise.ts:542:20)\n    at Promise._unwrapper (/home/martin/src/ts-promise/src/lib/Promise.ts:557:19)\n    at CallQueue.flush (/home/martin/src/ts-promise/src/lib/async.ts:47:4)\n    at Async.flush (/home/martin/src/ts-promise/src/lib/async.ts:116:19)\n    at Async._scheduledFlush (/home/martin/src/ts-promise/src/lib/async.ts:95:9)\n    at Object.Async._flusher [as _onImmediate] (/home/martin/src/ts-promise/src/lib/async.ts:58:50)\n    at processImmediate [as _immediateCallback] (timers.js:330:15)\n  from Promise at:\n    at Function.Promise.reject (/home/martin/src/ts-promise/src/lib/Promise.ts:211:11)\n    at /home/martin/src/promise-example/example.js:9:28\n    at Promise._unwrap (/home/martin/src/ts-promise/src/lib/Promise.ts:542:20)\n    at Promise._unwrapper (/home/martin/src/ts-promise/src/lib/Promise.ts:557:19)\n    at CallQueue.flush (/home/martin/src/ts-promise/src/lib/async.ts:47:4)\n    at Async.flush (/home/martin/src/ts-promise/src/lib/async.ts:116:19)\n    at Async._scheduledFlush (/home/martin/src/ts-promise/src/lib/async.ts:95:9)\n    at Object.Async._flusher [as _onImmediate] (/home/martin/src/ts-promise/src/lib/async.ts:58:50)\n    at processImmediate [as _immediateCallback] (timers.js:330:15)\n  from previous:\n    at Promise.then (/home/martin/src/ts-promise/src/lib/Promise.ts:181:15)\n    at Object.<anonymous> (/home/martin/src/promise-example/example.js:8:3)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n    at Function.Module.runMain (module.js:497:10)\n    at startup (node.js:119:16)\n    at node.js:902:3\n  from previous:\n    at Function.Promise.resolve (/home/martin/src/ts-promise/src/lib/Promise.ts:205:11)\n    at Object.<anonymous> (/home/martin/src/promise-example/example.js:7:25)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n    at Function.Module.runMain (module.js:497:10)\n    at startup (node.js:119:16)\n    at node.js:902:3\n```\n\n# Docs\n\nAll public methods and interfaces have JSDoc comments, so if your favorite IDE\nsupports these, you'll have instant inline documentation.\n\nThat said, the library's interface should be very unsurprising: basically ES6\nPromises with some extras.\n\nFor your convenience, here's a list of what's available on Promise.\n\nStatic methods on Promise:\n- `constructor(resolver: (resolve: (value: T | Thenable<T>) => void, reject: (reason: Error) => void) => void)`\n  Create a new Promise by passing a function that accepts\n  resolve and reject functions. Example:\n  ```ts\n  var p = new Promise((resolve, reject) => {\n      setTimeout(() => {\n          resolve(42);\n          // or e.g.: reject(new Error(\"boom\"));\n      }, 100);\n  });\n  ```\n  See ES6 Promise spec for details.\n- `static resolve<R>(value: R | Thenable<R>): Promise<R>`\n  Create an immediately resolved promise (in case of a 'normal' value), or a\n  promise that 'follows' another `Thenable` (e.g. a Promise from another\n  library).\n  See ES6 Promise spec for details.\n- `static resolve(): Promise<void>`\n  Convenience alias to create a `void`-Promise (for type-safety).\n  See ES6 Promise spec for details.\n- `static reject(reason: Error): Promise<any>`\n  Create an immediately rejected promise with `reason` as its rejection value.\n  See ES6 Promise spec for details.\n- `static all<X>(thenables: (X | Thenable<X>)[]): Promise<X[]>`\n  Create a promise that resolves to an array containing the results of resolving\n  all `Thenables` ('promises') in the input array (or simply their value, if\n  they're not a `Thenable`). If any of the input promises leads to a rejection,\n  the output promise is rejected with the reason of the first rejected promise.\n  See ES6 Promise spec for details.\n- `static race<X>(thenables: (X|Thenable<X>)[]): Promise<X>`\n  Create a promise that is resolved or rejected with the first resolved or\n  rejected Thenable (or 'plain' value) in the array. Note: the promise will\n  never resolve if the input array is empty.\n- `static delay(ms: number): Promise<void>`\n  Create a promise that resolves with `undefined` after `ms` milliseconds.\n- `static delay<R>(value: R|Thenable<R>, ms: number): Promise<R>`\n  Create a promise that resolves with given value after `ms` milliseconds.\n  If `value` is a `Thenable`, the timer will start when it is resolved.\n  If `value` is rejected, the resulting promise is also rejected, without\n  waiting for the timer.\n- `static defer<X>(): Deferred<X>`\n  Return an object containing a promise and its corresponding resolve and reject\n  functions. Note: most users will typically want to use the Promise constructor\n  instead, as e.g. thrown errors will then automatically lead to a rejected\n  promise.\n- `static setLongTraces(enable: boolean): void`\n  Enable or disable long stack trace support. See Example in README. Can be\n  enabled and disabled at runtime, and 'traced' and 'untraced' promises can be\n  mixed freely. Disabled by default, as it does incur both a performance and\n  memory overhead (though still about twice as fast as Q without long traces...).\n- `static flush(): void`\n  Recursively flush the async callback queue until all `.then()` and `.done()`\n  callbacks for fulfilled and rejected Promises have been called.\n  May throw an error (e.g. `UnhandledRejectionError`). It is safe to call\n  `flush()` again afterwards.\n  It is an error to call `flush` while it is already running.\n  Useful in e.g. unit tests to advance program state to the next 'async tick'.\n- `static setTracer(tracer: (promise: Promise<any>, msg: string) => void): void`\n  Debug helper to trace promise creation, callback attaching, fullfilments, etc.\n  Call with `null` to disable (default), or pass a function that's called during\n  various stages in a Promise's lifecycle. Note: this function's API is likely\n  going to change in the future (and may even be removed completely.)\n\nMethods on Promise instances:\n- `then<R>(onFulfilled?: (value: T) => R | Thenable<R>, onRejected?: (reason: Error) => R | Thenable<R>): Promise<R>`\n  See ES6 Promise spec\n- `catch<R>(onRejected?: (reason: Error) => R | Thenable<R>): Promise<R>`\n  See ES6 Promise spec\n- `done<R>(onFulfilled?: (value: T) => void | Thenable<void>, onRejected?: (reason: Error) => void | Thenable<void>): void`\n  `done()` behaves like `.then()` but does not return a new promise. Instead,\n  it throws an `UnhandledRejectionError` when the final result of the promise\n  chain is a rejected Promise (`.reason` property of the error).\n  Note that it is technically safe to 'continue' the program after e.g. catching\n  the error through Node's `uncaughtException`, or when running in a browser.\n- `finally(handler: (result: Promise<T>) => void|Thenable<void>): Promise<T>`\n  Asynchronous equivalent of try { } finally { }.\n  Runs `handler` when promise resolves (fulfilled or rejected).\n  Handler is passed the current promise (which is guaranteed to be\n  resolved), and can be interrogated with e.g. `isFulfilled()`, `.value()`,\n  etc.\n  When `handler` returns `undefined` or its promise is fulfilled, the\n  promise from `finally()` is resolved to the original promise's resolved\n  value or rejection reason.\n  If `handler` throws an error or returns a rejection, the result of\n  `finally()` will be rejected with that error.\n  Example:\n      someLenghtyOperation().finally((result) => {\n          if (result.isFulfilled()) {\n              console.log(\"succeeded\");\n          } else {\n              console.log(\"failed\", result.reason());\n          }\n      });\n- `isFulfilled(): boolean`\n  Returns true when promise is fulfilled, false otherwise.\n- `isRejected(): boolean`\n  Returns true when promise is rejected, false otherwise.\n- `isPending(): boolean`\n  Returns true when promise is still pending, false otherwise.\n- `value(): T`\n  Returns fulfillment value if fulfilled, otherwise throws an error.\n- `reason(): any`\n  Returns rejection reason if rejected, otherwise throws an error.\n- `toString(): string`\n  Returns a human-readable representation of the promise and its status.\n- `inspect(): string`\n  Returns a human-readable representation of the promise and its status.\n- `delay(ms: number): Promise<T>`\n  Create a promise that resolves with the same value of this promise, after\n  `ms` milliseconds. The timer will start when the current promise is resolved.\n  If the current promise is rejected, the resulting promise is also rejected,\n  without waiting for the timer.\n\n# TODO\n\nPlanned features (in fairly arbitrary order):\n- Auto-generate online docs using TypeDoc\n- Replace/update the (slightly out-of-date) docs above\n- Implement property-based catch() predicate (error constructor(s) and function\n  already done)\n- Possibly-unhandled-rejection detection\n- Non-V8-support: it works in non-V8, but long stack traces aren't available\n- Switch (back) to process.nextTick() / MutationObserver etc\n- Implement `.promisify()`\n- Simplify code somewhat more (most notably reduce duplication of 'called'-logic\n  when resolving, maybe also slightly simplify async callback queue\n  implementation)\n\nInteresting ideas that need further investigation:\n- Support for differentiating between programmer errors (e.g. assertions, null\n  derefences) and 'expected' errors. E.g. bluebird has `.error()` and the\n  concept of OperationalError, but this may not be the best way to interoperate\n  with other libraries.\n- Possibly-unterminated-promise-chain detection. Wild idea that could help to\n  always make sure to either return a promise from a function, or properly\n  terminate it, thus reducing the chance of a PossiblyUnhandledRejectionError at\n  runtime.\n- `.settle()` and/or other form of simply waiting for a bunch of void-promises,\n  but await all of them before returning, even in case of errors. To prevent\n  e.g. shutting things down while some tasks were still running.\n- Split off async callback queue and stack trace handling into separate packages\n  to allow re-use by other packages.\n\n- UMD support? Submit an issue if you think this is useful to you, as I'm more\n  of a browserify guy myself.\n\n\n# Development\n\nFound an issue? Have an idea? Wanna help? Submit an issue!\n\n```\ngit clone https://github.com/poelstra/ts-promise\ncd ts-promise\nnpm install\n# hack hack, code code...\nnpm run prepublish\n```\n\n# Changelog\n\nNotable changes listed below, for details see the version tags in Git.\n\n0.3.4 (2016-10-27):\n- Make Thenable interface more compatible with TS2's ES2015 promise, to let e.g. Promise.resolve() more easily accept it.\n- Optimize `Promise#return()` (without argument): very common case when converting a `Promise<X>` to a `Promise<void>`.\n\n0.3.3 (2016-10-18):\n- Fix unnecessary dependency on node typings in generated type definitions,\n  broke some builds (#13)\n\n0.3.2 (2016-10-10):\n- Fix TS2 not finding ts-promise typings\n- Switch to `@types` typings\n\n0.3.1 (2016-08-17):\n- Add opt-in `polyfill()`\n- Add experimental minified build (`dist/browser.min.js`)\n- Upgrade dev dependencies\n\n0.3.0 (2016-02-26):\n- Switch to `\"moduleResolution\": \"node\"`-compatible typings\n  - To use these typings, simply put that setting in your `tsconfig.json` and\n    remove the (manual) reference to the ts-promise.d.ts file from your project.\n- Update to latest Typescript (1.8.2)\n- Update to latest TSLint, fix linting errors\n- `async.setScheduler()` now uses `undefined` (instead of `null`) to reset,\n  but the old behaviour still works (though deprecated)\n\n0.2.5 (2016-02-08):\n- Replace previous `setImmediate` hack with non-global-polluting one (#8)\n\n0.2.4 (2016-01-30):\n- Stub `setImmediate` in case of browserify'ed environment (#8)\n\n0.2.3 (2015-08-27):\n- Fix stack overflow for very long unresolved promise chains\n- Simplify and document internal unwrapping logic\n\n0.2.2 (2015-08-04):\n- Implement `.finally()` (#3)\n- Add `Inspection<T>` interface (#4)\n- Don't confuse users by showing our internal stack trace when Node didn't provide one for UnhandledRejectionError\n\n0.2.1 (2015-06-24):\n- Improve stack trace for UnhandledRejectionError\n- Allow specifying Error classes with different constructor arguments in `.catch()`\n\n0.2.0 (2015-06-23):\n- Allow passing predicate to `.catch()` (Error class or array of them, or a\n  custom matching function)\n- Add `.return()` and `.throw()` helpers\n- Document all public members of Promise and UnhandledRejectionError\n- Stricter typing for `Promise.reject()`, no longer returns `Promise<any>` by\n  default\n- Require `.then()` and `.catch()` to have first callback (for typing only,\n  implementation supports full Promises/A+)\n- Include .ts sources to not confuse debugger due to sourcemaps also being\n  included\n- Fix building on Windows\n\n0.1.5  (2015-05-17):\n- Add Promise.race()\n- Add .delay() on Promise and instance\n\n0.1.4  (2015-05-13):\n- Add longStackTraces support to .done()\n- Export VoidDeferred interface and allow resolving it with a Thenable<void>\n- Add .toString() and .inspect()\n\n0.1.3  (2015-05-09):\n- Add Promise.defer()\n- Add stack to BaseError\n- Add rejection reason to UnhandledRejectionError\n- 100% code coverage\n\n0.1.2 (2015-05-07):\n- Fix bundled .d.ts file for default export\n- Add synchronous inspection API\n- Export BaseError (to be moved to separate package later)\n\n0.1.1 (2015-05-06):\n- Transparent support for mocked timers (e.g. Sinon.useFakeTimers())\n\n0.1.0 (2015-05-04):\n- Initial version\n\n# License\n\nThe MIT license.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/poelstra/ts-promise.git"
  },
  "scripts": {
    "browserify": "browserify --node --standalone ts-promise ./dist/lib/index.js > ./dist/browser.js",
    "build": "npm run -s build:test && npm run -s build:src && npm run -s browserify && npm run -s minify",
    "build:src": "cd src/lib && tsc",
    "build:test": "cd src/test && tsc",
    "clean": "rimraf -rf dist",
    "cover": "istanbul cover --report json _mocha -- -R spec dist/test/test-*.js && remap-istanbul -i coverage/coverage-final.json -t html -o coverage/html-report",
    "lint": "tslint -t verbose src/**/*.ts",
    "minify": "uglifyjs ./dist/browser.js --compress --mangle --mangle-props --mangle-regex='/^_/' --reserved 'Promise' > ./dist/browser.min.js",
    "mocha": "mocha -R spec dist/test/test-*.js",
    "prepublish": "npm run -s build && npm run -s test",
    "test": "npm run -s lint && npm run -s mocha",
    "watch:src": "cd src/lib && tsc --watch",
    "watch:test": "cd src/test && tsc --watch"
  },
  "types": "./dist/lib/index.d.ts",
  "typings": "./dist/lib/index.d.ts",
  "version": "0.3.4"
}
